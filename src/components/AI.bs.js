// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as Shared$ReactHooksTemplate from "../Shared.bs.js";

function getAvailableSpots(board) {
  return List.filter((function (value) {
                  return value !== "";
                }))(List.flatten(List.mapi((function (rowIndex, row) {
                        return List.mapi((function (tileIndex, value) {
                                      var match = value === /* Empty */0;
                                      if (match) {
                                        return String(rowIndex) + String(tileIndex);
                                      } else {
                                        return "";
                                      }
                                    }), row);
                      }), board)));
}

function getBestScoreMove(scoreMoves, player) {
  if (player) {
    return List.hd(List.sort((function (param, param$1) {
                      return param[0] - param$1[0] | 0;
                    }), scoreMoves));
  } else {
    return List.hd(List.rev(List.sort((function (param, param$1) {
                          return param[0] - param$1[0] | 0;
                        }), scoreMoves)));
  }
}

function minimax(board, player) {
  var flattened = List.flatten(board);
  var avaialableTiles = getAvailableSpots(board);
  var gameState = Shared$ReactHooksTemplate.checkGameStatus(Shared$ReactHooksTemplate.winTable, flattened, /* Turn */Block.__(0, [player]));
  var getScores = function (moves) {
    return List.map((function (move) {
                  var updatedBoard = Shared$ReactHooksTemplate.makeMove(board, move, gameState);
                  var match = minimax(updatedBoard, Shared$ReactHooksTemplate.oppositePlayer(player));
                  return /* tuple */[
                          match[0],
                          move
                        ];
                }), moves);
  };
  if (typeof gameState === "number") {
    if (gameState === 0) {
      if (avaialableTiles) {
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "AI.re",
                60,
                2
              ]
            ];
      } else {
        return /* tuple */[
                0,
                ""
              ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.match_failure,
            /* tuple */[
              "AI.re",
              60,
              2
            ]
          ];
    }
  } else if (gameState.tag) {
    if (gameState[0]) {
      return /* tuple */[
              10,
              ""
            ];
    } else {
      return /* tuple */[
              -10,
              ""
            ];
    }
  } else {
    return getBestScoreMove(getScores(avaialableTiles), player);
  }
}

function getBestMove(board) {
  var match = minimax(board, /* Computer */1);
  var move = match[1];
  console.log("---------Final Score--------");
  console.log(match[0], move);
  return move;
}

export {
  getAvailableSpots ,
  getBestScoreMove ,
  minimax ,
  getBestMove ,
  
}
/* No side effect */
