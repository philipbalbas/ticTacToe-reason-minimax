// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as Shared$ReactHooksTemplate from "../Shared.bs.js";

function getAvailableSpots(board) {
  return List.filter((function (value) {
                  return value !== "";
                }))(List.flatten(List.mapi((function (rowIndex, row) {
                        return List.mapi((function (tileIndex, value) {
                                      var match = value === /* Empty */0;
                                      if (match) {
                                        return String(rowIndex) + String(tileIndex);
                                      } else {
                                        return "";
                                      }
                                    }), row);
                      }), board)));
}

function getBestMoveScore(scoreMoves, player) {
  var match = player === /* Computer */1;
  var initialEval = match ? /* tuple */[
      -1000,
      ""
    ] : /* tuple */[
      1000,
      ""
    ];
  return Belt_List.reduce(scoreMoves, initialEval, (function (param, param$1) {
                var curMove = param$1[1];
                var curScore = param$1[0];
                var bestMove = param[1];
                var bestScore = param[0];
                if (player) {
                  var match = curScore > bestScore;
                  if (match) {
                    return /* tuple */[
                            curScore,
                            curMove
                          ];
                  } else {
                    return /* tuple */[
                            bestScore,
                            bestMove
                          ];
                  }
                } else {
                  var match$1 = curScore < bestScore;
                  if (match$1) {
                    return /* tuple */[
                            curScore,
                            curMove
                          ];
                  } else {
                    return /* tuple */[
                            bestScore,
                            bestMove
                          ];
                  }
                }
              }));
}

function minimax(board, player) {
  var flattened = List.flatten(board);
  var avaialableTiles = getAvailableSpots(board);
  var gameState = Shared$ReactHooksTemplate.checkGameStatus(Shared$ReactHooksTemplate.winTable, flattened, /* Turn */Block.__(0, [player]));
  var getScores = function (moves) {
    return List.map((function (move) {
                  var updatedBoard = Shared$ReactHooksTemplate.makeMove(board, move, gameState);
                  var match = minimax(updatedBoard, Shared$ReactHooksTemplate.oppositePlayer(player));
                  return /* tuple */[
                          match[0],
                          move
                        ];
                }), moves);
  };
  if (typeof gameState === "number") {
    if (gameState === 0) {
      if (avaialableTiles) {
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "AI.re",
                50,
                2
              ]
            ];
      } else {
        return /* tuple */[
                0,
                ""
              ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.match_failure,
            /* tuple */[
              "AI.re",
              50,
              2
            ]
          ];
    }
  } else if (gameState.tag) {
    if (gameState[0]) {
      return /* tuple */[
              10,
              ""
            ];
    } else {
      return /* tuple */[
              -10,
              ""
            ];
    }
  } else {
    return getBestMoveScore(getScores(avaialableTiles), player);
  }
}

function getBestMove(board) {
  var match = minimax(board, /* Computer */1);
  var move = match[1];
  console.log("---------Final Score--------");
  console.log(match[0], move);
  return move;
}

export {
  getAvailableSpots ,
  getBestMoveScore ,
  minimax ,
  getBestMove ,
  
}
/* No side effect */
